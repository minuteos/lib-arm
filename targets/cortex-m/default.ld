/*
 * Copyright (c) 2018 triaxis s.r.o.
 * Licensed under the MIT license. See LICENSE.txt file in the repository root
 * for full license information.
 *
 * cortex-m/default.ld
 *
 * LD script for Cortex-M series MCUs
 */

OUTPUT_FORMAT("elf32-littlearm")
OUTPUT_ARCH(arm)
ENTRY(Reset_Handler)

MEMORY {
    UIDS (r)  : ORIGIN = 0x00000000, LENGTH = 64K
}

/* stack ends at the top of the RAM, minimal size reserved to warn during compilation */
STACK_RESERVED = 8K;

/* Memory map with segments FLASH and RAM should be provided by a more specific target */
INCLUDE memmap.ld

/* Typically used for bootloader stored at the beginning of app flash */
INCLUDE sections_pre.ld

/* Typically used for additional bootloader running before the main application */
INCLUDE sections_pre2.ld

SECTIONS {
    __boot_end = .;

    /* Cortex-M image starts with an ISR table which also contains the initial SP */
    .text.isr_vector : {
        __app_start = .;
        KEEP(*(.isr_vector))
        . = ALIGN(4);
    } >FLASH
}

INCLUDE sections_post_isr.ld

SECTIONS {
    /* code (.text), constants (.rodata), and linktime grouped declarations (.rospec) */
    .text : {
        *(.text)
        *(.text*)
        *(.rodata)
        *(.rodata*)
        KEEP(*(SORT(.rospec*)))
        . = ALIGN(4);
    } >FLASH

    /* libc initialization */
    .text.init_array : {
        PROVIDE_HIDDEN(__init_array_start = .);
        KEEP(*(SORT(.init_array.*)))
        KEEP(*(.init_array*))
        PROVIDE_HIDDEN(__init_array_end = .);
    } >FLASH

    .text.ARM.extab :
    {
        *(.ARM.extab* .gnu.linkonce.armextab.*)
    } >FLASH

    __exidx_start = .;
    .text.ARM.exidx :
    {
        *(.ARM.exidx* .gnu.linkonce.armexidx.*)
    } >FLASH
    __exidx_end = .;

    /* end of FLASH data */
    __text_end = .;

    /* reserved stack space at the bottom of RAM */
    .stack : {
        __ram_start = .;
        __stack_start = .;
        . += STACK_RESERVED;
        __stack_end = .;
    } >RAM

    /* BSS starts with the system vector table (has to be 512-byte aligned, stack size usually is),
     * followed by the dual-entry interrupt delegate table (ISR + param)
     */
    .bss : {
        . = ALIGN(512);
        *(.bss.isr_vector_sys)
        *(.bss.isr_vector)

        /* start of true BSS */
        __bss_start = .;
        *(.bss)
        *(.bss*)
        *(COMMON)
        . = ALIGN(4);
        __bss_end = .;
    } >RAM

    /* We also have a section for uninitialized data */
    .nobss (NOLOAD) : {
        __nobss_start = .;
        *(.nobss)
        *(.nobss*)
        . = ALIGN(4);
        __nobss_end = .;
    } >RAM

    /* pre-initialized data to be copied to RAM, stored in FLASH */
    .data : AT(__text_end) {
        __data_load = LOADADDR(.data);
        __data_start = .;
        *(.data)
        *(.data*)
        . = ALIGN(4);
        __data_end = .;
    } >RAM

    __data_load_end = __text_end + SIZEOF(.data);

    /* allocation heap */
    .heap : {
        __heap_start = .;
        . = ORIGIN(RAM) + LENGTH(RAM);
        __heap_end = .;
        __ram_end = .;
    } >RAM

    /* 1-based symbol IDs generated by the linker */
    .id 1 (NOLOAD) : {
        *(.uid)
        *(.uid*)
    } >UIDS

    /* special section at end of image for checksum/signature/etc */
    .sig : AT(__text_end + SIZEOF(.data)) {
        KEEP(*(.sig))
        KEEP(*(.sig*))
    } >FLASH
}

INCLUDE sections_post.ld
